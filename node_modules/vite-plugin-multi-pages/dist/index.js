var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../vite-plugin/vite-plugin-multi-pages/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => mpa
});
module.exports = __toCommonJS(src_exports);
var import_connect_history_api_fallback = __toESM(require("connect-history-api-fallback"));

// ../../vite-plugin/vite-plugin-multi-pages/package.json
var name = "vite-plugin-multi-pages";

// ../../vite-plugin/vite-plugin-multi-pages/src/utils/index.ts
var import_fast_glob = __toESM(require("fast-glob"));
var import_path = __toESM(require("path"));
var import_yargs = __toESM(require("yargs"));
var argv = import_yargs.default.argv;
function getFirstPage(pages) {
  const firstPageName = Object.keys(pages)[0];
  return `/${firstPageName}/index.html`;
}
function genFileName(pageName, path2) {
  const xPath = path2 === "" ? "" : `${path2}/`;
  return `${xPath}${pageName}.html`.replace(/^pages\//, "");
}
function parseEntryFile(file, filters = []) {
  const fileSplit = file.split("/");
  const pageName = fileSplit.slice(2, -1).join("/");
  const outputPath = fileSplit.slice(1, fileSplit.length - 2).join("/");
  return {
    file,
    pageName,
    outputPath,
    include: filters.includes(pageName) || filters.length === 0
  };
}
function parseFiles(files, defaultEntries) {
  const args = argv?.entry || argv?.file || argv?.page || "";
  if (args === "") {
    defaultEntries = "";
  }
  const filters = args.split(",").concat(defaultEntries.split(",")).filter((_) => _);
  const ret = files.map((file) => parseEntryFile(file, filters));
  return {
    allEntries: ret,
    entries: ret.filter((e) => e.include),
    args
  };
}
function scanFile2Html(current, scanFile, filename) {
  const reStr = `${scanFile.split(".")[0]}[.](.*)`;
  const entryRe = new RegExp(reStr);
  return current.replace(entryRe, filename);
}
function getSpecialPageNames(specialPageNames) {
  let _specialPageNames;
  if (specialPageNames) {
    if (specialPageNames.includes(",")) {
      _specialPageNames = `{${specialPageNames}}`;
    } else {
      _specialPageNames = specialPageNames;
    }
  } else {
    _specialPageNames = "**";
  }
  return _specialPageNames;
}
function getIgnorePageNames(ignorePageNames) {
  let _ignorePageNames;
  if (ignorePageNames) {
    if (ignorePageNames.includes(",")) {
      _ignorePageNames = `{${ignorePageNames}}`;
    } else {
      _ignorePageNames = ignorePageNames;
    }
  } else {
    _ignorePageNames = "";
  }
  return _ignorePageNames;
}
function getPagesInfo({
  defaultEntries,
  scanDir,
  scanFile,
  specialPageNames,
  ignorePageNames
}) {
  const allFiles = import_fast_glob.default.sync(
    `${scanDir}/${getSpecialPageNames(specialPageNames)}/${scanFile}`.replace(
      "//",
      "/"
    ),
    {
      ignore: [
        `${scanDir}/${getIgnorePageNames(ignorePageNames)}/${scanFile}`.replace(
          "//",
          "/"
        )
      ]
    }
  );
  const pages = {};
  const result = parseFiles(allFiles, defaultEntries);
  const { entries } = result;
  entries.forEach((entry) => {
    const { file, pageName, outputPath } = entry;
    pages[pageName] = {
      entry: file,
      filename: genFileName(pageName, outputPath)
    };
  });
  return pages;
}
function getMPAIO(root, options) {
  const { scanFile, filename } = options;
  const pages = getPagesInfo(options);
  const input = {};
  Object.keys(pages).map((key) => {
    input[key] = import_path.default.resolve(
      root,
      scanFile2Html(pages[key].entry, scanFile, filename)
    );
  });
  return input;
}
function getHistoryReWriteRuleList(options) {
  const { scanDir, scanFile, filename, rewrites } = options;
  const list = rewrites;
  list.push({
    from: /^\/$/,
    to: `./${scanDir}/index/${filename}`
  });
  const pages = getPagesInfo(options);
  Object.keys(pages).map((pageName) => {
    const to = `./${scanFile2Html(pages[pageName].entry, scanFile, filename)}`;
    list.push({
      from: new RegExp(`^/${pageName}/index.html/*`),
      to
    });
    list.push({
      from: new RegExp(`^/${pageName}/index.html$`),
      to
    });
    list.push({
      from: new RegExp(`^/${pageName}.html$`),
      to
    });
    list.push({
      from: new RegExp(`^/${pageName}$`),
      to
    });
  });
  return list;
}

// ../../vite-plugin/vite-plugin-multi-pages/src/index.ts
function mpa(userOptions = {}) {
  const options = {
    defaultOpenPage: "/",
    scanDir: "src/views",
    scanFile: "main.{js,ts,jsx,tsx}",
    defaultEntries: "",
    filename: "index.html",
    rewrites: [],
    specialPageNames: "",
    ignorePageNames: "",
    ...userOptions
  };
  if (!options.scanFile?.includes(".")) {
    console.error(
      `[${name}]: scanFile should be something like main.ts/main.{js,ts}/index.js/index{ts,tsx}`
    );
    process.exit(1);
  }
  return {
    name,
    enforce: "pre",
    config(config) {
      const openBool = typeof options.defaultOpenPage === "boolean";
      config.build = config.build || {};
      config.build.rollupOptions = config.build.rollupOptions || {};
      config.build.rollupOptions.input = getMPAIO(
        config.root || process.cwd(),
        options
      );
      config.server = config.server || {};
      config.server.open = options.defaultOpenPage ? openBool ? getFirstPage(config.build.rollupOptions.input) : options.defaultOpenPage === "/" ? "/" : "/" + options.defaultOpenPage : false;
    },
    configureServer({ middlewares: app }) {
      app.use(
        (0, import_connect_history_api_fallback.default)({
          verbose: Boolean(process.env.DEBUG) && process.env.DEBUG !== "false",
          disableDotRule: void 0,
          htmlAcceptHeaders: ["text/html", "application/xhtml+xml"],
          rewrites: getHistoryReWriteRuleList(options)
        })
      );
    }
  };
}
